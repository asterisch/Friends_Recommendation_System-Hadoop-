package Mapred;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import org.apache.hadoop.io.*;import org.apache.hadoop.mapred.MapReduceBase;import org.apache.hadoop.mapred.OutputCollector;import org.apache.hadoop.mapred.Reducer;import org.apache.hadoop.mapred.Reporter;import org.apache.log4j.Logger;import relations.Friend_Tuple;/** * * @author asteriosc */public class Reduce extends MapReduceBase implements Reducer<Text, Friend_Tuple, Text, Text> {    public static Logger log = Logger.getLogger(Reduce.class);    private final int common_friends_limit = 3;    @Override    public void reduce(Text toUser, Iterator<Friend_Tuple> fr_friendof_fr, OutputCollector<Text, Text> output, Reporter rprtr) throws IOException {        HashMap<String, Integer> users_friends = new HashMap<>();        ArrayList<String> toUser_friends = new ArrayList<>();        while (fr_friendof_fr.hasNext())         {            Friend_Tuple user_friend = fr_friendof_fr.next();                                            if (user_friend.getFriend().equals("null"))             // If user is toUser's friend add him to friend's list            {                toUser_friends.add(user_friend.getUser());                //log.info(user_friend.getUser());            }             else             {                if (users_friends.containsKey(user_friend.getUser())) // Sum up common friends number of every friend                {                    int temp = users_friends.get(user_friend.getUser());                    users_friends.put(user_friend.getUser(), ++temp);                }                 else                 {                    users_friends.put(user_friend.getUser(),1);                }            }        }        StringBuilder suggests=new StringBuilder();                 // Collect all suggestions to a single string        for(String user:users_friends.keySet())        {          //  log.info(user+" commons: "+users_friends.get(user));            if(users_friends.get(user)>=common_friends_limit)       // If a toUser's friend has more common friends with toUser than the limit            {                if(!toUser_friends.contains(user) && !suggests.toString().contains(user)) // if suggested friend is already friend with toUser, reject him                {                    suggests.append(user).append(" ");              // Safely add a user to suggestion list for toUser                }            }        }        output.collect(new Text(toUser), new Text(suggests.toString()));            }}