package Mapred;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import org.apache.hadoop.io.*;import org.apache.hadoop.mapred.MapReduceBase;import org.apache.hadoop.mapred.OutputCollector;import org.apache.hadoop.mapred.Reducer;import org.apache.hadoop.mapred.Reporter;import org.apache.log4j.Logger;import relations.Friend_Tuple;/** * * @author asteriosc */public class Reduce extends MapReduceBase implements Reducer<Text, Friend_Tuple, Text, Text> {    public static Logger log = Logger.getLogger(Reduce.class);    private final int common_friends_limit = 10;    @Override    public void reduce(Text toUser, Iterator<Friend_Tuple> fr_friendof_fr, OutputCollector<Text, Text> output, Reporter rprtr) throws IOException {        HashMap<String, Integer> users_friends = new HashMap<>();        HashMap<String,ArrayList<String>> suggests_from = new HashMap<>();        ArrayList<String> toUser_friends = new ArrayList<>();        while (fr_friendof_fr.hasNext())         {            Friend_Tuple user_friend = fr_friendof_fr.next();                                            if (user_friend.getFriend().equals("null"))             // If user is toUser's friend add him to friend's list            {                toUser_friends.add(user_friend.getUser());                //log.info(user_friend.getUser());            }             else             {                if (users_friends.containsKey(user_friend.getUser())) // Sum up common friends number of every friend                {                    int temp = users_friends.get(user_friend.getUser());                    users_friends.put(user_friend.getUser(), ++temp);                    suggests_from.get(user_friend.getUser()).add(user_friend.getFriend());                }                 else                 {                    users_friends.put(user_friend.getUser(),1);                    ArrayList<String> temp = new ArrayList<>();                    temp.add(user_friend.getFriend());                    suggests_from.put(user_friend.getUser(), temp);                }            }        }        StringBuilder suggests=new StringBuilder();                 // Collect all suggestions to a single string        for(String user:users_friends.keySet())        {          //  log.info(user+" commons: "+users_friends.get(user));            boolean unknown=true;            for(String un:suggests_from.get(user))            {                if(users_friends.get(un)>=common_friends_limit)                 {                    unknown=false;                    break;                }            }                if(!toUser_friends.contains(user) && !suggests.toString().contains(user) && !unknown) // if suggested friend is already friend with toUser, reject him                {                    suggests.append(user).append(" ");              // Safely add a user to suggestion list for toUser                }                    }        if (suggests.toString().length()>1) output.collect(new Text(toUser), new Text(suggests.toString()));            }}